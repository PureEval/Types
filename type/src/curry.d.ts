import type { Fn, LabeledStartParams } from "../type-utils"

type Curring<Params extends unknown[], ReturnType, NewParams extends unknown[] = []> =
  Params extends [infer _Next, ...infer Remaining]  // `...LabeledStartParams<Params, 1>]` is used instead of `_Next` to keep tuple label
  ? LabeledStartParams<Params, 1> extends (infer NextParamTuple extends unknown[])
  ? {
    (...args: [...NewParams, ...NextParamTuple]): CurriedReturnType<Remaining, ReturnType>
  } & (
    Remaining extends []
    ? {}
    : Curring<Remaining, ReturnType, [...NewParams, ...NextParamTuple]>
  )
  : never
  : ReturnType

type CurriedReturnType<Params extends unknown[], ReturnType> =
  Params extends []
  ? ReturnType
  : Curring<Params, ReturnType>

/**
 * Wrap a function with this to get a curried version
 */
export type Curry<F extends Fn> =
  Parameters<F>['length'] extends (0 | 1)
  ? F
  : CurriedReturnType<Parameters<F>, ReturnType<F>>

/**
 * @example
 * const foo = (a, b, c) => a + b + c;
 * curry(foo)(1, 2, 3); //6
 * curry(foo)(1)(2, 3); //6
 */
export function curry<F extends Fn>(func: F): Curry<F>

/**
 * @deprecated param check for `uncurry` has not done yet.  
 * You have to make sure that the function is generated by `curry`.
 * @example
 * const foo = (a, b, c) => a + b + c;
 * uncurry(curry(foo)(1)); //(b, c) -> 1 + b + c
 */
export function uncurry<
  F extends Fn,
>(func: F): (...args: Parameters<F>) => ReturnType<F>;
